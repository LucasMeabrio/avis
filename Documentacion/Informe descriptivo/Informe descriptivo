Informe Descriptivo del Proyecto de Simulador de Vuelo Realista

Carátula:

Logo del Proyecto:

Título:
Simulador de Vuelo Realista con Control de Variadores de Frecuencia y Panel de Instrumentos Físicos

Nombre del Proyecto y Año:  
SKYFLY - 7° 2° Aviónica

Link a la Web:  
https://estebanlautaro.github.io/Paginaweb-SKYFLY/

Link a Trello:
https://trello.com/b/u9Dn0bU8/kanban

Link a GitHub:  
https://github.com/brizuu750/SKYLF

Link a Redes Sociales:  
Instagram: https://www.instagram.com/skylf.proyect/ 
Tiktok: https://www.tiktok.com/@skyfly826?_t=8qnCGQhRKsA&_r=1

Diseño de la Carátula:  
(Insertar diseño gráfico de la carátula)

Presentación del Equipo:

Lautaro Esteban:

Mail: Lautyesteban14@gmail.com

Linkedin: Lautaro Sebastian Esteban

Instagram: @lauty.esteban

Santiago Rubio:

Mail: Santy201205@gmail.com

Linkedin: Santiago Rubio

Instagram: @santy_201205

Lucas Meabrio:

Mail: Meabriolucas@gmail.com

Linkedin: Lucas Meabrio

Instagram: @lucass_meab

Leandro Flores:

Mail: leandro200flores@gmail.com

Linkedin: Leandro Flores

Instagram: @lean.floresss

Agustin Brizuela:

Mail: brizuu750@gmail.com

Linkedin: Agustin Lionel Brizuela

Instagram: @agustiin.brizuela

Santiago Leiva:

Mail: Santiagoleiva745@gmail.com

Linkedin: Santiago Leiva

Instagram: @leivva.s

Emiliano Romocordoba:

Mail: Romoemiliano324@gmail.com

Jofiel Godoy Baldovino:

Mail: Markbaldj@gmail.com

Linkedin: Marco Baldovino

Instagram:@jofiel_godoy

Horas dedicadas por cada integrante:  

Participaron un total de 8 personas en un promedio de 14 hs semanales durante 28 semanas aproximadamente

Índice General

1. Introducción
2. Objetivo
3. Descripción de la Solución Buscada
4. Segmento Destino y Alcance
5. Captura Representativa del Proyecto
6. Diagrama en Bloques del Proyecto
7. Resultado Conseguido
8. Software
9. Sistema Embebido
10. Electrónica
11. Estructura
12. Anexo

1. Introducción
Este proyecto de Simulador de Vuelo Realista, basado en la cabina del Cessna 152, replica las maniobras y controles de la aeronave mediante la integración de un panel físico de control y un sistema de visualización interactuando con Flight Simulator 2020. Se implementa un circuito de comunicación mediante un Arduino UNO y un ESP32 que permiten gestionar diversos sistemas y enviar comandos a través de variables de comunicación específicas, sincronizando los instrumentos físicos con el simulador virtual. Además, el simulador utiliza un sistema de control de motores con variadores de frecuencia y sensor de movimiento MPU6050 para añadir realismo en el control de vuelo.

2. Objetivo
Objetivo General: Construir un simulador de vuelo con una interfaz de usuario realista, que permita experimentar el control de una aeronave tipo Cessna 152 mediante un panel físico conectado a Flight Simulator 2020.
Objetivo Específico: Integrar un sistema de variadores de frecuencia, Arduino UNO y ESP32, junto con un panel de control que permita al usuario activar sistemas de vuelo, como el control de luces, bomba de combustible y buses aviónicos, replicando el entorno real de un avión en el simulador virtual.

3. Descripción de la Solución
El simulador incluye dos sistemas principales: un Panel de Control y un Panel de Visualización de Instrumentos, con un esquema de comunicación que integra varios componentes para emular los controles de un avión real.
Panel de Control
El Panel de Control cuenta con interruptores de palanca, pulsadores, y una llave selectora rotativa de 6 estados. Este panel físico permite al usuario activar sistemas esenciales de la aeronave en el entorno virtual de Flight Simulator 2020, mediante la integración de MobiFlight y Arduino UNO. Algunos de los sistemas principales controlados por el panel incluyen:
Bomba de Combustible: Activa una bomba de combustible que permite el cebado inicial del motor.
Luces (BCN, LAND, TAXI, NAV, STRB): Controla las luces exteriores del avión para el despegue, aterrizaje y condiciones de vuelo específicas.
Interruptores de Bus Aviónico: Activa los sistemas de navegación y comunicación de la aeronave.
Tubo Pitot: Controla el calentador del tubo Pitot para evitar el congelamiento.
Magnetos: Distribuyen corriente eléctrica a las bujías, gestionadas por una llave rotativa de 6 estados.
El Arduino UNO es el microcontrolador principal del panel de control y se configura mediante MobiFlight para ejecutar comandos específicos en Flight Simulator 2020 según los interruptores activados. Esto asegura que cada acción en el panel tenga un reflejo preciso en el simulador virtual, mejorando la inmersión en el entorno de vuelo.
Comunicación con el Variador de Frecuencia y Sistema de Control de Movimiento
Para lograr una experiencia de vuelo más realista, el simulador utiliza un variador de frecuencia GK500-2T1.5B controlado por un ESP32 y un módulo RS485 para gestionar el movimiento de los motores, lo que permite simular inclinaciones en los ejes de cabeceo y alabeo. La configuración del variador de frecuencia y el sistema de comunicación están organizados de la siguiente forma:
ESP32 y RS485: El ESP32 actúa como el controlador principal para la comunicación con el variador de frecuencia. La conexión se realiza mediante el protocolo RS485, que permite la transmisión de datos en tiempo real para ajustar la velocidad y dirección de los motores, necesarios para las maniobras de vuelo.
Configuración de Pines del RS485 y ESP32:
RS485:
Pines GND y VCC conectados a una fuente de 5V.
Pines A y B conectados directamente al variador de frecuencia.
Pin RE conectado al GPIO4 del ESP32, DE al GPIO2, RO al GPIO16 (RX) y DI al GPIO17 (TX).
MPU6050:
Pines GND y VCC conectados al ESP32.
SCL al GPIO22 y SDA al GPIO21.

Tasa de Transferencia: La comunicación con el variador de frecuencia se realiza a una velocidad de 9600 baudios. Esto permite un control preciso y estable de los motores, alineando las respuestas del sistema físico con los comandos generados en el simulador.
Sensor de Movimiento MPU6050: Integrado al ESP32, el MPU6050 detecta la inclinación y aceleración en tiempo real, lo que permite ajustar los movimientos del simulador para reflejar las maniobras de vuelo de manera más precisa. Este sensor es crucial para sincronizar el sistema físico con los cambios en el entorno virtual del Flight Simulator 2020.
Panel de Visualización de Instrumentos
Este panel de visualización está diseñado para mostrar los datos de vuelo en una pantalla de 18 pulgadas, reflejando los instrumentos de la aeronave. La comunicación de los datos de vuelo se realiza mediante MobiFlight y FSUIPC7, que gestionan las variables de Flight Simulator 2020. Este diseño permite una representación en tiempo real de los parámetros del simulador, ajustando el diseño para que se asemeje al de un Cessna 152.

4. Segmento Destino y Alcance
Este simulador está destinado a estudiantes de ingeniería, entusiastas de la aviación y centros de enseñanza técnica que busquen herramientas de formación práctica en sistemas de control, mecánica de vuelo y electrónica aplicada. El proyecto tiene el potencial de ser una plataforma educativa completa en simulación de vuelo.

5. Captura Representativa del Proyecto

6. Diagrama en Bloques del Proyecto

7. Resultados Conseguido
Se trabaja en la implementación de la conexión y funcionamiento del panel de control con Flight Simulator 2020. Las pruebas iniciales de los motores todavía está en proceso. El sistema continúa en fase de pruebas y optimización, principalmente en el uso de variables de comunicación para mejorar la precisión de las lecturas y comandos en tiempo real, y también la comunicación con el variador de frecuencias

8. Software
Diagrama en Bloques:
Lenguajes Utilizados:
C/C++: Programación del ESP32 y Arduino UNO para la comunicación con los variadores de frecuencia.
C/C++: Programación del Arduino UNO para gestionar los interruptores.
Capturas de Código y Herramientas:
Fragmentos de código en Arduino IDE para el control del ESP32 y la programación de los instrumentos con MobiFlight.
Configuración de FSUIPC7 para la personalización de los instrumentos en pantalla.

Estructuras de Datos:

Las librerías principales usadas en el variador de frecuencias son:
ModbusMaster: Esta librería permite la comunicación Modbus RTU entre el ESP32 y el variador de frecuencia, facilitando la lectura y escritura de registros Modbus. Es útil para enviar comandos de control y recibir estados o lecturas de dispositivos Modbus.
MPU6050: Esta librería permite gestionar el sensor MPU6050, que proporciona datos de aceleración y giroscopio, esenciales para el cálculo de orientación y movimientos en el simulador. La comunicación se realiza a través de I2C, y la librería facilita la lectura de los valores en tiempo real.

Variables Globales para Configuración Básica:
Almacenan parámetros básicos de la comunicación Modbus que se usan en varias partes del código, lo que facilita cambios futuros.
const uint8_t slaveID = 1; // ID del dispositivo esclavo (variador de frecuencia)
const uint16_t baudRate = 9600; // Tasa de baudios para la comunicación RS485
const uint16_t startAddress = 0x301; // Dirección de inicio del registro a leer/escribir

Array para Almacenar Resultados de Lecturas:
Almacena los datos leídos de diferentes registros Modbus, facilitando la manipulación o el monitoreo de múltiples registros a la vez.

uint16_t modbusData[10]; // Array para almacenar los datos de los registros leídos

Estructura para el Estado de la Comunicación:
Guarda los códigos de error o el estado de éxito de cada comunicación, lo cual es útil para realizar un diagnóstico.

struct ModbusStatus {
    bool success;         // Indica si la última comunicación fue exitosa
    uint8_t errorCode;    // Código de error, si la comunicación falló
};

ModbusStatus modbusStatus;

Función de Lectura con Retorno de Estado:
Realiza la lectura de registros y devuelve el estado de la operación, facilitando el manejo de errores.

ModbusStatus readRegister(uint16_t address) {
    ModbusStatus status;
    uint8_t result = node.readHoldingRegisters(address, 1);
    if (result == node.ku8MBSuccess) {
        modbusData[0] = node.getResponseBuffer(0);
        status.success = true;
    } else {
        status.success = false;
        status.errorCode = result;
    }
    return status;
}

Array de Direcciones de Registros para Pruebas Automáticas:
Si se requiere probar varios registros, este array permite iterar sobre ellos y verificar cuáles son válidos.

const uint16_t testAddresses[] = {0x301, 0x302, 0x303, /* otros registros */};

Flags de Control para Optimizar la Ejecución:
Bandera para controlar el tiempo de espera y evitar retardos innecesarios en la comunicación.

bool timeoutFlag = false;

9. Sistema Embebido
Componentes:
ESP32: Controlador central para los variadores de frecuencia y MPU6050.
Arduino UNO: Controla el panel de control, configurado con MobiFlight para activar los instrumentos.
Protocolo y Conexiones:
RS485: Protocolo para la comunicación con el variador de frecuencia.
I2C: Utilizado por el MPU6050 para la detección de movimiento y aceleración.
Configuración de Pines:
RS485:
GND y VCC a una fuente de 5V
A y B al variador de frecuencia
RE al GPIO4, DE al GPIO2, RO al GPIO16 (RX), DI al GPIO17 (TX) del ESP32
MPU6050:
GND y VCC al ESP32
SCL al GPIO22, SDA al GPIO21

10. Electrónica
Diagrama en Bloques:
Componentes y Configuraciones:
Variador de Frecuencia GK500-2T1.5B: Utilizado para controlar los motores a través del protocolo RS485, con una tasa de transferencia de 9600 baudios.
Arduino UNO: Control del panel de instrumentos.
MPU6050: Detección de movimiento y orientación para simular los ejes de vuelo.
Esquemático de Conexión y Fuente de Alimentación:
Fuente de alimentación separada para el ESP32 y variador de frecuencia, asegurando estabilidad y seguridad en la operación.
